#lang racket

(require "svg.rkt")
(require "../lib/load/all.rkt")

(provide points->smoothed-points points->smooth-path points->path)

(define (smooth-next-triplet-c points fct #:k-limit (k-limit 20))
  (cond
    ((= (length points) 1)
      (let* ((p1 (first points))
            (x1 (car p1))
            (y1 (cdr p1)))
          (list x1 y1)))
    ((= (length points) 2)
      (let* ((p1 (first points))
            (p2 (second points))
            (x1 (car p1))
            (y1 (cdr p1))
            (x2 (car p2))
            (y2 (cdr p2))
            (c1x (- x2 (* (- x2 x1) fct)))
            (c1y (- y2 (* (- y2 y1) fct)))
            (c2x x2)
            (c2y y2))
          (list x2 y2 x2 y2)))
    ((>= (length points) 3)
      (let* ((p1 (first points))
            (p2 (second points))
            (p3 (third points))
            (x1 (car p1))
            (y1 (cdr p1))
            (x2 (car p2))
            (y2 (cdr p2))
            (x3 (car p3))
            (y3 (cdr p3))
            (k (if (= x1 x3)
                    #f
                    (/ (- y3 y1 0.0) (- x3 x1))))
            (fct (if (> (abs k) k-limit)
                    (* 1.0 (/ 1 k) fct)
                    fct)))
              (let*-values
                    (((c1x c1y c2x c2y)
                      (if k
                        (let* ((a1 (- y2 (* k x2)))
                              (dx1 (* (- x2 x1) fct))
                              ;(dx1 (if (< dx1 0) (- dx1) dx1))
                              (dx2 (* (- x3 x2) fct))
                              ;(dx2 (if (< dx2 0) (- dx2) dx2))
                              (c1y (+ a1 (* k (- x2 dx1))))
                              (c1y-a (+ a1 (* k (- x2 (- dx1)))))
                              (c1x (- x2 dx1))
                              (c1x-a (- x2 (- dx1)))
                              (c2y (+ a1 (* k (+ x2 dx2))))
                              (c2y-a (+ a1 (* k (+ x2 (- dx2)))))
                              (c2x (+ x2 dx2))
                              (c2x-a (+ x2 (- dx2)))
                              (inverse-1? (>
                                            (distance c1x c1y x1 y1)
                                            (distance c1x-a c1y-a x1 y1)))
                              (inverse-2? (>
                                            (distance c2x c2y x3 y3)
                                            (distance c2x-a c2y-a x3 y3)))
                              (c1x (if inverse-1? c1x-a c1x))
                              (c1y (if inverse-1? c1y-a c1y))
                              (c2x (if inverse-2? c2x-a c2x))
                              (c2y (if inverse-2? c2y-a c2y))
                              ;(_ (when (or
                              ;            (> (distance c2x c2y x2 y2) 50)
                              ;            (> (distance c1x c1y x2 y2) 50))
                              ;      (printf "x1=~a, y1=~a, x2=~a, y2=~a, x3=~a, y3=~a, dx1=~a, dx2=~a, k=~a, a1=~a, c1x=~a, c1y=~a, c2x=~a, c2y=~a~n" x1 y1 x2 y2 x3 y3 dx1 dx2 k a1 c1x c1y c2x c2y)))
                         )
                            (values c1x c1y c2x c2y))
                        (let* ((dy1 (* (- y2 y1) fct))
                              (dy2 (* (- y3 y2) fct))
                              (c1y (- y2 dy1))
                              (c1x x2)
                              (c2y (+ y2 dy2))
                              (c2x x2))
                            (values c1x c1y c2x c2y)))))
                  (merge (list c1x c1y x2 y2 c2x c2y) (smooth-next-triplet-c (cdr points) fct)))))
    (else null)))

(define (points->smoothed-points points #:fct (fct 3))
  (merge
    (list (caar points) (cdar points) (caar points) (cdar points))
    (smooth-next-triplet-c points fct)))

; '((1 . 2) (30 . 8) ... (500 . 328)) -> "M1,2 C ..."
(define (points->smooth-path points #:fct (fct 3))
  (let ((smoothed-points (points->smoothed-points points #:fct fct)))
    (for/fold
      ((s (format "M~a,~a C" (first smoothed-points) (second smoothed-points))))
      ((p (partition (ltrim smoothed-points 2) 6)))
      (format "~a ~a,~a ~a,~a ~a,~a "
                s
                (nth p 1)
                (nth p 2)
                (nth p 3)
                (nth p 4)
                (nth p 5)
                (nth p 6)))))

(define (points->path points)
  (for/fold
    ((s (format "M~a,~a L" (caar points) (cdar points))))
    ((p (cdr points)))
    (format "~a ~a,~a" s (car p) (cdr p))))
